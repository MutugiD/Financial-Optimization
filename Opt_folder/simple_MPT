import numpy as pd 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns
from pypfopt.cla import CLA
from matplotlib.ticker import FuncFormatter
import datetime
import matplotlib.pyplot as plt
from scipy.optimize import minimize 
import scipy.stats as stats
import math
import sys
import os

start_date = '2010-06-29'
end_date = '2020-08-10'

Q_e_min = 0.55 #minimum acceptable rate for E
Q_s_min = 0.60 #minimum acceptable rate for S
Q_g_min = 0.60 #minimum acceptable rate for G

target_return = 0.00167 #annualized return


df_AAL = pd.read_csv(r'E:\Python Projects\Portfolio_Management_Jason\Data\dataset\AAL.csv', index_col=0, parse_dates=True)
df_AAPL = pd.read_csv(r'E:\Python Projects\Portfolio_Management_Jason\Data\dataset\AAPL.csv', index_col=0, parse_dates=True)
df_AMZN = pd.read_csv(r'E:\Python Projects\Portfolio_Management_Jason\Data\dataset\AMZN.csv', index_col=0, parse_dates=True)
df_NFLX = pd.read_csv(r'E:\Python Projects\Portfolio_Management_Jason\Data\dataset\NFLX.csv', index_col=0, parse_dates=True)
df_TSLA = pd.read_csv(r'E:\Python Projects\Portfolio_Management_Jason\Data\dataset\MSFT.csv',index_col=0, parse_dates=True )
df_ESG= pd.read_csv(r'E:\Python Projects\Portfolio_Management_Jason\esg_scores_raw.csv')
df_ESG['avg_ESG']= (df_ESG['environmental_score'] + df_ESG['social_score'] + df_ESG['gover_score'])/3


Adj_Close = df_AAL['Adj Close'], df_AAPL['Adj Close'],  df_AMZN['Adj Close'], df_NFLX['Adj Close'], df_TSLA['Adj Close']
df_Close = pd.DataFrame(Adj_Close, index = ['AAL', 'AAPL','AMZN', 'NFLX','TSLA']).T.loc[start_date:end_date]
returns = df_Close.pct_change(1).iloc[1:]
r = np.array(np.mean(returns, axis=0))
e = np.ones(len(r))
mean_avg_ESG = df_ESG['avg_ESG'].mean()
std_avg_ESG= np.std(df_ESG['avg_ESG'])
df_ESG['norm_ESG']=stats.norm.cdf((df_ESG['avg_ESG']-mean_avg_ESG)/std_avg_ESG)

Q = df_ESG['norm_ESG']

Q_min = (Q_e_min+Q_s_min+Q_g_min)/3

def objective(w):
    a = np.dot(w,r)
    b = np.log(1+a)    
    
    return np.mean(b)
w = np.zeros(len(r)) + 1 / len(r)

const = ({'type' : 'ineq' , 'fun' : lambda w: np.dot(w,r) - target_return},
         {'type' : 'ineq' , 'fun' : lambda w: np.dot(w,Q) - Q_min},
         {'type' : 'eq' , 'fun' : lambda w: np.dot(w, e) - 1})


non_neg = []
for i in range(len(r)):
    non_neg.append((0,None))
non_neg = tuple(non_neg)

solution = minimize(fun=objective, x0=-w, method='SLSQP',constraints=const,
                    bounds=non_neg)
w = solution.x.round(6)

print (w)
print (w.sum())
list = returns.columns[w > 0.0]
print(list)
